from manimlib import *
import numpy as np
from scipy.optimize import fsolve

class ImprovedWaves(Scene):
    def construct(self):      
        # è®¾ç½®æ›´å¥½çš„3Dè§†è§’
        self.camera.frame.set_euler_angles(
            theta=81.08 * DEGREES,
            phi=77.95 * DEGREES,
            gamma=0 * DEGREES
        )
        self.camera.frame.set_height(5.75)        # 3Dåæ ‡ç³»
        axes = ThreeDAxes(
            x_range=(-5, 5, 1),
            y_range=(-5, 5, 1),
            z_range=(-6, 6, 1),
            height=6,
            width=6,
            depth=6,
            axis_config={"include_ticks": False, }
        )
          # xyåœ°é¢åŠ æ–¹æ ¼æ•ˆæœ
        # åˆ›å»ºç½‘æ ¼åœ°é¢
        
        
        # æ·»åŠ å¹³è¡Œäºxè½´çš„çº¿æ¡ï¼ˆæ²¿yæ–¹å‘ï¼‰
        for y in np.arange(-5, 5.1, 0.5):  # æ¯0.5å•ä½ä¸€æ¡çº¿
            line = Line3D(
                start=axes.c2p(-5, y, 0),
                end=axes.c2p(5, y, 0),
                color=GREY,
                
                opacity=0.3
            )
            self.add(line)
        
        # æ·»åŠ å¹³è¡Œäºyè½´çš„çº¿æ¡ï¼ˆæ²¿xæ–¹å‘ï¼‰
        for x in np.arange(-5, 5.1, 0.5):  # æ¯0.5å•ä½ä¸€æ¡çº¿
            line = Line3D(
                start=axes.c2p(x, -5, 0),
                end=axes.c2p(x, 5, 0),
                color=GREY,
                
                opacity=0.3
            )
            self.add(line)
        ##åˆ›å»ºå‚ç›´xyåœ°é¢çš„ï¼Œä¸”y=5ï¼Œz^2+x^2=25çš„åœ†,é‡Œé¢å‡åŒ€åˆ†å¸ƒå¹³è¡ŒZè½´ç­‰è·çš„åæ¡çº¿æ¡
        # 1. é¦–å…ˆåˆ›å»ºåœ†çš„è½®å»“ï¼ˆè®©åœ†å½¢æ›´æ˜æ˜¾ï¼‰
        circle_points = []
        num_points = 100
        for i in range(num_points + 1):
            theta = 2 * np.pi * i / num_points
            x = 5 * np.cos(theta)  # åŠå¾„ä¸ºæ ¹å·5
            z = 5 * np.sin(theta)
            y = 5  # å›ºå®šåœ¨y=5å¹³é¢
            circle_points.append(axes.c2p(x, y, z))

        # åˆ›å»ºåœ†å½¢è½®å»“
        circle_outline = VMobject()
        circle_outline.set_points_as_corners(circle_points)
        circle_outline.set_stroke(color=GREY, width=3, opacity=0.3)
        self.add(circle_outline)

        # 2. åœ¨åœ†å†…åˆ›å»ºå¹³è¡ŒäºZè½´çš„ç­‰è·çº¿æ¡ï¼ˆ10æ¡ï¼‰
        x_positions = np.linspace(-4, 4, 10)  # 10æ¡ç­‰è·çº¿æ¡

        for x in x_positions:
            if x**2 <= 25:  # ç¡®ä¿xåœ¨åœ†çš„èŒƒå›´å†…
                # è®¡ç®—è¯¥xä½ç½®ä¸‹åœ†çš„zèŒƒå›´ï¼šz = Â±âˆš(25-xÂ²)
                z_max = np.sqrt(25 - x**2)
                z_min = -z_max
                
                # åˆ›å»ºå¹³è¡ŒäºZè½´çš„çº¿æ¡ï¼ˆåœ¨y=5å¹³é¢å†…ï¼‰
                line = Line3D(
                    start=axes.c2p(x, 5, z_min),
                    end=axes.c2p(x, 5, z_max),
                    color=GREY,
                    
                    opacity=0.3
                )
                self.add(line)


        

        

        self.camera.frame.move_to((-1.29, -0.51, 0.76))

        self.camera.frame.save_state()  # ä¿å­˜åˆå§‹ç›¸æœºçŠ¶æ€
        # ç”»ä¸€æ¡z=3*sqrt(3),x=0çš„ç›´çº¿
        line = Line(
            start=axes.c2p(0, -5, 3*np.sqrt(3)),
            end=axes.c2p(0, 5, 3*np.sqrt(3)),
            color=WHITE,
            stroke_width=4
        )
        axes.add(line)
        
        # æ·»åŠ ç›´çº¿æ ‡ç­¾
        line_label = TexText(r"$z = 3\sqrt{3}$", font_size=48)
        line_label.set_color(WHITE)
        line_label.fix_in_frame()
        line_label.to_corner(UR)
        self.add(line_label)

        dt = ValueTracker(value=0)
        
        # ParametricCurve: å‚æ•°æ–¹ç¨‹å®šä¹‰
        curve1 = ParametricCurve(
            lambda t: axes.c2p(0, t, 5*np.cos(t)),
            t_range=[-5, 5, 0.1]
        )
        curve2 = ParametricCurve(
            lambda t: axes.c2p(0, t, -np.cos(5*t+dt.get_value())),
            t_range=[-5, 5, 0.1]
        )
        curve3 = ParametricCurve(
            lambda t: axes.c2p(0, t, 5*np.cos(t) - np.cos(5*t + dt.get_value())),
            t_range=[-5, 5, 0.1]
        )
        
        # è®¾ç½®æ›²çº¿é¢œè‰²
        curve1.set_stroke(color=BLUE, width=4)
        curve2.set_stroke(color=RED, width=4)
        curve3.set_stroke(color=GREEN, width=4)
        
        # æ·»åŠ æ›´æ–°å™¨
        curve2.add_updater(lambda m: m.become(
            ParametricCurve(
                lambda t: axes.c2p(0, t, -np.cos(5*t+dt.get_value())),
                t_range=[-5, 5, 0.1],
                color=RED,
                stroke_width=4
            )
        ))
        curve3.add_updater(lambda m: m.become(
            ParametricCurve(
                lambda t: axes.c2p(0, t, 5*np.cos(t) - np.cos(5*t + dt.get_value())),
                t_range=[-5, 5, 0.1],
                color=GREEN,
                stroke_width=4
            )
        ))
        
        # æ·»åŠ æ ‡ç­¾
        label1 = TexText(r"$z_1 = 5\cos(y)$", font_size=48)
        label1.set_color(BLUE)
        label1.fix_in_frame()
        label1.to_corner(UL)

        label2 = TexText(r"$z_2 = -\cos(5y + \delta t)$", font_size=48)
        label2.set_color(RED)
        label2.fix_in_frame()
        label2.next_to(label1, DOWN, aligned_edge=LEFT)

        label3 = TexText(r"$z_3 = 5\cos(y) - \cos(5y + \delta t)$", font_size=48)
        label3.set_color(GREEN)
        label3.fix_in_frame()
        label3.next_to(label2, DOWN, aligned_edge=LEFT)
        
        self.add(label1, label2, label3)

        # æ˜¾ç¤ºtå€¼çš„æ ‡ç­¾
        t_value_label = DecimalNumber(
            dt.get_value(), 
            num_decimal_places=2,
            font_size=48
        )
        t_value_label.set_color(YELLOW)
        t_value_label.fix_in_frame()
        t_value_label.add_updater(lambda m: m.set_value(dt.get_value()))
        
        # æ·»åŠ tçš„è¯´æ˜æ–‡å­—
        t_label = TexText(r"$\delta t = $", font_size=48)
        t_label.set_color(YELLOW)
        t_label.fix_in_frame()
        t_label.next_to(t_value_label, LEFT)
        
        t_group = VGroup(t_label, t_value_label)
        t_group.next_to(label3, DOWN, aligned_edge=LEFT)        # è®¡ç®—äº¤ç‚¹çš„å‡½æ•°ï¼ˆæ”¹è¿›ç‰ˆæœ¬ï¼‰
        def find_intersections(delta_t):
            """
            æ‰¾åˆ°ç›´çº¿ z = 3*sqrt(3) å’Œæ›²çº¿ z3 = 5*cos(y) - cos(5*y + delta_t) çš„äº¤ç‚¹
            å³æ±‚è§£æ–¹ç¨‹: 5*cos(y) - cos(5*y + delta_t) = 3*sqrt(3)
            """
            target_z = 3 * np.sqrt(3)  # â‰ˆ 5.196
            intersections = []
            
            # å®šä¹‰è¦æ±‚è§£çš„æ–¹ç¨‹
            def equation(y):
                return 5 * np.cos(y) - np.cos(5 * y + delta_t) - target_z
            
            # å®šä¹‰æ–¹ç¨‹çš„å¯¼æ•°
            def equation_derivative(y):
                return -5 * np.sin(y) + 5 * np.sin(5 * y + delta_t)
            
            # ä½¿ç”¨æ›´ç»†å¯†çš„ç½‘æ ¼æœç´¢ï¼ˆæé«˜åˆ†è¾¨ç‡ï¼‰
            y_dense = np.linspace(-5, 5, 500)  # å¢åŠ åˆ°500ä¸ªç‚¹
            eq_vals = np.array([equation(y) for y in y_dense])
            
            # æ‰¾åˆ°ç¬¦å·å˜åŒ–ç‚¹
            sign_changes = []
            for i in range(len(eq_vals) - 1):
                if eq_vals[i] * eq_vals[i + 1] < 0:
                    # ä½¿ç”¨çº¿æ€§æ’å€¼å¾—åˆ°æ›´å¥½çš„åˆå§‹çŒœæµ‹
                    y1, y2 = y_dense[i], y_dense[i + 1]
                    f1, f2 = eq_vals[i], eq_vals[i + 1]
                    y_interpolated = y1 - f1 * (y2 - y1) / (f2 - f1)
                    sign_changes.append(y_interpolated)
            
            # é¢å¤–çš„å¤šé‡åˆå§‹çŒœæµ‹ç­–ç•¥
            # æ·»åŠ ä¸€äº›åŸºäºå‡½æ•°ç‰¹å¾çš„é¢å¤–çŒœæµ‹ç‚¹
            extra_guesses = []
            
            # åŸºäºcoså‡½æ•°çš„å‘¨æœŸæ€§ï¼Œåœ¨å…³é”®ç‚¹é™„è¿‘æœç´¢
            critical_points = [0, np.pi/3, 2*np.pi/3, np.pi, 4*np.pi/3, 5*np.pi/3, 2*np.pi]
            for cp in critical_points:
                if -5 <= cp <= 5:
                    extra_guesses.append(cp)
                if -5 <= -cp <= 5:
                    extra_guesses.append(-cp)
            
            # åˆå¹¶æ‰€æœ‰åˆå§‹çŒœæµ‹
            all_guesses = sign_changes + extra_guesses
            
            # ç²¾ç¡®æ±‚è§£æ¯ä¸ªæ ¹
            for initial_guess in all_guesses:
                try:
                    # ä½¿ç”¨æ›´å®½æ¾ä½†å®ç”¨çš„å‚æ•°
                    with np.errstate(all='ignore'):  # å¿½ç•¥æ•°å€¼è­¦å‘Š
                        y_solution = fsolve(
                            equation, 
                            initial_guess,
                            fprime=equation_derivative,
                            xtol=1e-10,  # æ›´é«˜ç²¾åº¦
                            maxfev=500   # æ›´å¤šè¿­ä»£æ¬¡æ•°
                        )[0]
                    
                    # éªŒè¯è§£çš„æœ‰æ•ˆæ€§
                    if (-5 <= y_solution <= 5 and 
                        abs(equation(y_solution)) < 1e-8):  # æ›´ä¸¥æ ¼çš„ç²¾åº¦è¦æ±‚
                        
                        # æ£€æŸ¥æ˜¯å¦ä¸ºæ–°è§£ï¼ˆæ›´å°çš„å®¹å·®ï¼‰
                        is_new = True
                        for existing_y, _ in intersections:
                            if abs(y_solution - existing_y) < 1e-4:  # æ›´å°çš„é‡å¤åˆ¤æ–­å®¹å·®
                                is_new = False
                                break
                        
                        if is_new:
                            intersections.append((y_solution, target_z))
                
                except (RuntimeError, ValueError):
                    # é™é»˜å¤„ç†æ”¶æ•›å¤±è´¥
                    continue
            
            # æ’åºäº¤ç‚¹ä»¥ä¾¿ç¨³å®šæ˜¾ç¤º
            intersections.sort(key=lambda x: x[0])
            return intersections# åˆ›å»ºäº¤ç‚¹çš„ç‚¹å¯¹è±¡
        intersection_dots = []  # æ”¹ä¸ºæ™®é€šåˆ—è¡¨è€Œä¸æ˜¯VGroup
        
        def update_intersections():
            """æ›´æ–°äº¤ç‚¹ä½ç½®"""
            nonlocal intersection_dots
            
            # ç§»é™¤æ—§çš„äº¤ç‚¹
            for dot in intersection_dots:
                self.remove(dot)
            intersection_dots.clear()
            
            # è®¡ç®—æ–°çš„äº¤ç‚¹
            current_dt = dt.get_value()
            intersections = find_intersections(current_dt)
            
            # åˆ›å»ºæ–°çš„äº¤ç‚¹
            for y_coord, z_coord in intersections:
                point_pos = axes.c2p(0, y_coord, z_coord)
                
                # ä½¿ç”¨GlowDotåˆ›å»ºå‘å…‰æ•ˆæœçš„äº¤ç‚¹
                glow_dot = GlowDot(
                    center=point_pos,
                    radius=0.05,  # æ›´å°çš„åŠå¾„
                    color=ORANGE,
                    glow_factor=5.0,  # æ›´å¼ºçš„å‘å…‰æ•ˆæœ
  
                )
                
                intersection_dots.append(glow_dot)
                self.add(glow_dot)
        
        # æ·»åŠ äº¤ç‚¹æ›´æ–°å™¨
        def intersection_updater(mob):
            update_intersections()
        
        # åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿå¯¹è±¡æ¥è§¦å‘äº¤ç‚¹æ›´æ–°
        intersection_tracker = VMobject()
        intersection_tracker.add_updater(intersection_updater)
        
        # æ·»åŠ äº¤ç‚¹æ•°é‡æ ‡ç­¾

        
        # æ›´æ–°äº¤ç‚¹æ•°é‡çš„å‡½æ•°
        def update_intersection_count(mob):
            current_dt = dt.get_value()
            intersections = find_intersections(current_dt)
            mob.set_value(len(intersections))        # æ·»åŠ æ‰€æœ‰å…ƒç´ åˆ°åœºæ™¯
        self.add(axes)

        self.add(t_label, t_value_label)
        self.add(curve1, curve2, curve3)
        self.add(intersection_tracker)  # æ·»åŠ äº¤ç‚¹è·Ÿè¸ªå™¨# è®¾ç½®ç›¸æœºè§†è§’ (åœ¨åŠ¨ç”»å¼€å§‹å‰)
        self.camera.frame.set_euler_angles(
            theta=81.08 * DEGREES,
            phi=77.95 * DEGREES,
            gamma=0 * DEGREES
        )
        self.camera.frame.set_height(5.75)
        self.camera.frame.move_to((-1.29, -0.51, 0.76))

        # åˆå§‹åŒ–äº¤ç‚¹
        update_intersections()

        # åŠ¨ç”»
        self.play(
            dt.animate.set_value(2 * PI),
            run_time=5,
            rate_func=smooth
        )

  
       ##      self.camera.frame.move_to((0, 0, 3*np.sqrt(3)))
        self.play(
            self.camera.frame.animate
                .move_to((0, 0, 1.5*np.sqrt(3)))
                .scale(0.2),
            run_time=3,
            rate_func=smooth
        )


        self.play(
            dt.animate.set_value(0),
            run_time=5,
            rate_func=smooth
        )
        self.play(
            self.camera.frame.animate.restore(),  # æ¢å¤ç›¸æœºåˆ°åˆå§‹çŠ¶æ€
            run_time=3,
            rate_func=smooth
        )
        # æ—‹è½¬ç›¸æœº
                # æ›¿æ¢ç¬¬354-371è¡Œçš„ä»£ç ï¼š
        
        def cinematic_camera_rotation():
            """ç”µå½±çº§ç›¸æœºæ—‹è½¬ - å¤šè½´åè°ƒ"""
            original_angles = self.camera.frame.get_euler_angles()
            original_center = self.camera.frame.get_center()
            
            def update_camera(mob, alpha):
                # ä½¿ç”¨æ­£å¼¦å‡½æ•°åˆ›å»ºæ›´è‡ªç„¶çš„è¿åŠ¨
                smooth_alpha = 0.5 * (1 - np.cos(PI * alpha))  # Sæ›²çº¿æ’å€¼
                
                # ä¸»æ—‹è½¬ï¼šç»•å‚ç›´è½´
                phi_rotation = 0.2 * np.sin(4 * PI * alpha)
                
                # å‰¯æ—‹è½¬ï¼šè½»å¾®çš„ä¸Šä¸‹æ‘†åŠ¨
                theta_wobble = 2 * PI * smooth_alpha
                # è½»å¾®çš„å·¦å³æ‘†åŠ¨
                gamma_wobble = 0.2 * np.sin(2 * PI * alpha)
                # è·ç¦»å˜åŒ–ï¼šè½»å¾®çš„ç¼©æ”¾æ•ˆæœ
                distance_factor = 1 + 0.1 * np.sin(2 * PI * alpha)

                theta = original_angles[0] + theta_wobble
                phi = original_angles[1] + phi_rotation
                gamma = original_angles[2] + gamma_wobble

                mob.set_euler_angles(theta=theta, phi=phi, gamma=gamma)
                
                # å¯é€‰ï¼šè½»å¾®æ”¹å˜è§‚å¯Ÿè·ç¦»
                new_height = 5.75 * distance_factor
                mob.set_height(new_height)
            
            return UpdateFromAlphaFunc(self.camera.frame, update_camera)
        
        # æ‰§è¡Œç”µå½±çº§æ—‹è½¬
        self.play(
            cinematic_camera_rotation(),
            run_time=8,
            rate_func=linear
        )
        
        # æ·»åŠ è°ƒè¯•åŠŸèƒ½
        def show_camera_info():
            """æ˜¾ç¤ºç›¸æœºä¿¡æ¯"""
            theta, phi, gamma = self.camera.frame.get_euler_angles()
            center = self.camera.frame.get_center()
            height = self.camera.frame.get_height()
            
            print("=" * 50)
            print("ğŸ“· ç›¸æœºä¿¡æ¯:")
            print(f"  Î¸ (theta): {theta/DEGREES:.2f}Â°")
            print(f"  Ï† (phi): {phi/DEGREES:.2f}Â°")
            print(f"  Î³ (gamma): {gamma/DEGREES:.2f}Â°")
            print(f"  ä¸­å¿ƒä½ç½®: ({center[0]:.2f}, {center[1]:.2f}, {center[2]:.2f})")
            print(f"  è§†é‡é«˜åº¦: {height:.2f}")
            print("=" * 50)
        def show_current_intersections():
            """æ˜¾ç¤ºå½“å‰äº¤ç‚¹ä¿¡æ¯"""
            current_dt = dt.get_value()
            intersections = find_intersections(current_dt)
            print(f"\nCurrent Î´t = {current_dt:.3f}")
            print(f"Number of intersections: {len(intersections)}")
            for i, (y, z) in enumerate(intersections):
                print(f"  Intersection {i+1}: y = {y:.3f}, z = {z:.3f}")
        
        self.show_camera_info = show_camera_info
        self.show_current_intersections = show_current_intersections
        self.find_intersections = find_intersections
        print("ğŸ¯ Intersection calculation feature added!")
        print("ğŸ’¡ Available commands in interactive mode:")
        print("   self.show_current_intersections() - Show current intersections")
        print("   self.find_intersections(Î´t_value) - Calculate intersections for specific Î´t")
        
        self.embed()

if __name__ == "__main__":
    import os
    os.system("manimgl c.py ImprovedWaves")