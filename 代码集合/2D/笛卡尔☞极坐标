from manimlib import *
import numpy as np

class WarpCartesianToPolar(Scene):
    def construct(self):        # 1. 设置初始标题
        title = Text("Coordinate Transform: Cartesian to Polar",
                      font_size=60).to_edge(UP)
        title.set_color_by_gradient(BLUE, GREEN, YELLOW, ORANGE, RED)
        
        cartesian_eq = Tex("y = 5\\cos(x) - \\cos(5x)", color=BLUE, font_size=50)
        cartesian_eq.set_color_by_gradient(BLUE, GREEN, YELLOW, ORANGE, RED)
        cartesian_eq.next_to(title, DOWN)
        
        self.play(Write(title), Write(cartesian_eq))
        self.wait(1)

        # 2. 创建笛卡尔坐标系
        self.camera.frame.set_height(10)
        
        # 创建坐标平面
        plane = NumberPlane(
            x_range=[-PI, PI, PI/6],
            y_range=[-6, 6, 1],
            background_line_style={
                "stroke_color": BLUE_B,
                "stroke_width": 1,
                "stroke_opacity": 0.4
            },
            axis_config={
                "stroke_color": WHITE,
                "stroke_width": 2,
                "include_tip": True
            }
        )
        
        # 添加坐标轴标签
        x_label = Tex("x", color=WHITE, font_size=40).next_to(plane.x_axis.get_end(), RIGHT)
        y_label = Tex("y", color=WHITE, font_size=40).next_to(plane.y_axis.get_end(), UP)
          # 创建函数图形 - 关键：使用更多点来确保精度
        def cartesian_func(x):
            return 5 * np.cos(x) - np.cos(5 * x)
        
        # 创建参数化的曲线，而不是使用plane.get_graph
        t_values = np.linspace(-PI, PI, 1000)  # 使用大量点确保精度
        curve_points = []
        for t in t_values:
            x = t
            y = cartesian_func(t)
            curve_points.append(plane.c2p(x, y))

        cartesian_curve = VMobject()
        cartesian_curve.set_points_smoothly(curve_points)
        cartesian_curve.set_stroke(YELLOW, width=3)
        
        # 创建笛卡尔坐标网格线
        grid_lines = VGroup()
        
        # 水平网格线
        for y_val in np.arange(-6, 7, 1):  # 从-6到6，每隔1画一条线
            if y_val != 0:  # 跳过x轴（已经存在）
                start_point = plane.c2p(-PI, y_val)
                end_point = plane.c2p(PI, y_val)
                h_line = Line(start_point, end_point, 
                            color=BLUE_C, stroke_width=1, stroke_opacity=0.6)
                grid_lines.add(h_line)
        
        # 垂直网格线
        for x_val in np.arange(-PI, PI + PI/6, PI/6):  # 每隔π/6画一条线
            if abs(x_val) > 0.01:  # 跳过y轴（已经存在）
                start_point = plane.c2p(x_val, -6)
                end_point = plane.c2p(x_val, 6)
                v_line = Line(start_point, end_point, 
                            color=BLUE_C, stroke_width=1, stroke_opacity=0.6)
                grid_lines.add(v_line)
        
        # 创建网格点用于观察变换
        grid_dots = VGroup()
        for x in np.linspace(-PI, PI, 13):  # x方向13个点
            for y in np.linspace(-6, 6, 13):  # y方向13个点
                dot = Dot(plane.c2p(x, y), radius=0.02, color=TEAL)
                grid_dots.add(dot)
        self.play(
            FadeOut(title),
            FadeOut(cartesian_eq),
            ShowCreation(plane),
            Write(x_label),
            Write(y_label)
        )
        self.play(
            ShowCreation(grid_lines),
            ShowCreation(cartesian_curve), 
            FadeIn(grid_dots)
        )
        self.wait(1)

        # 3. 显示变换公式
        transform_text = Tex("Transform: (x,y) \\to (r\\cos\\theta, r\\sin\\theta)",
                             font_size=50, color=GREEN)
        transform_text.to_edge(DOWN)
        self.play(Write(transform_text))
        self.wait(1)        # 4. 关键：统一变换所有元素
        # 设置缩放因子以确保极坐标图形大小合适
        scale_factor = 1  # 缩放因子，使变换后的图形大小合适
        
        # 创建新的极坐标曲线 - 正确处理极坐标变换
        polar_curve_points = []
        for t in t_values:
            theta = t  # x坐标成为角度
            r = cartesian_func(t)  # y坐标成为半径
            
            # 处理负半径：将负半径转换为正半径，角度加π
            if r < 0:
                r = -r
                theta = theta + PI
            
            # 计算极坐标点并使用c2p方法转换
            x_polar = r * np.cos(theta) * scale_factor
            y_polar = r * np.sin(theta) * scale_factor
            # 使用plane.c2p()方法进行正确的坐标转换
            polar_curve_points.append(plane.c2p(x_polar, y_polar))
        
        polar_curve = VMobject()
        polar_curve.set_points_smoothly(polar_curve_points)
        polar_curve.set_stroke(YELLOW, width=3)
        
        # 变换网格线 - 为每条线创建极坐标版本
        polar_lines = VGroup()
        
        for line in grid_lines:
            # 获取线的起点和终点
            start_cart = plane.p2c(line.get_start())
            end_cart = plane.p2c(line.get_end())
            
            # 在线上创建多个点进行变换
            line_points = []
            num_points = 50  # 每条线使用50个点
            for i in range(num_points + 1):
                t = i / num_points
                x_cart = start_cart[0] + t * (end_cart[0] - start_cart[0])
                y_cart = start_cart[1] + t * (end_cart[1] - start_cart[1])
                  # 应用极坐标变换
                if abs(y_cart) > 0.1:  # 避免半径过小的点
                    theta = x_cart
                    r = y_cart
                    # 处理负半径
                    if r < 0:
                        r = -r
                        theta = theta + PI
                
                    x_polar = r * np.cos(theta) * scale_factor
                    y_polar = r * np.sin(theta) * scale_factor
                    line_points.append(plane.c2p(x_polar, y_polar))
            
            if len(line_points) >= 2:  # 只有当有足够的点时才创建线
                polar_line = VMobject()
                polar_line.set_points_smoothly(line_points)
                polar_line.set_stroke(BLUE_C, width=1, opacity=0.6)
                polar_lines.add(polar_line)
        
        # 变换网格点 - 确保正确的极坐标变换
        polar_dots = VGroup()
        for dot in grid_dots:
            # 获取原始笛卡尔坐标
            original_pos = plane.p2c(dot.get_center())
            x_cart = original_pos[0]  # 角度θ
            y_cart = original_pos[1]  # 半径r
            
            # 应用极坐标变换，避免r=0的点
            if abs(y_cart) > 0.2:  
                theta = x_cart
                r = y_cart
                  # 处理负半径
                if r < 0:
                    r = -r
                    theta = theta + PI
                
                new_x = r * np.cos(theta) * scale_factor
                new_y = r * np.sin(theta) * scale_factor
                # 使用plane.c2p()方法进行正确的坐标转换
                new_dot = Dot(plane.c2p(new_x, new_y), radius=0.02, color=TEAL)
                polar_dots.add(new_dot)
        
        # 5. 执行变换动画 - 分步骤进行
        # 首先显示即将进行的变换        self.play(
            Indicate(transform_text, color=YELLOW, scale_factor=1.2),
            run_time=1
        
        
        # 然后执行变换
        self.play(
            # 同时变换曲线、网格线和网格点
            ReplacementTransform(cartesian_curve, polar_curve),
            ReplacementTransform(grid_lines, polar_lines),
            ReplacementTransform(grid_dots, polar_dots),
            run_time=5,
            rate_func=smooth
        )
        self.wait(1)        # 6. 添加极坐标网格 - 调整大小以匹配变换后的图形
        polar_grid = VGroup()
          # 径向线（角度线）
        max_radius = 6 * scale_factor  # 匹配函数的最大半径
        for angle in np.arange(0, TAU, TAU/12):
            start_point = plane.c2p(0, 0)  # 使用c2p方法转换原点
            end_point = plane.c2p(max_radius * np.cos(angle), max_radius * np.sin(angle))
            line = Line(start_point, end_point, 
                       color=PURPLE, stroke_width=1, stroke_opacity=0.4)
            polar_grid.add(line)
        
        # 同心圆（半径线）
        for radius in np.arange(scale_factor, max_radius + scale_factor, scale_factor):
            # 创建圆的点
            circle_points = []
            for angle in np.linspace(0, TAU, 100):
                x = radius * np.cos(angle)
                y = radius * np.sin(angle)
                circle_points.append(plane.c2p(x, y))
            
            circle = VMobject()
            circle.set_points_smoothly(circle_points)
            circle.set_stroke(PURPLE, width=1, opacity=0.4)
            polar_grid.add(circle)
          # 极坐标标签 - 使用c2p方法正确定位
        r_label_pos = plane.c2p(max_radius*0.8, 0.3)
        theta_label_pos = plane.c2p(-0.3, max_radius*0.8)
        r_label = Tex("r", color=WHITE, font_size=40).move_to(r_label_pos)
        theta_label = Tex("\\theta", color=WHITE, font_size=40).move_to(theta_label_pos)
        
        self.play(
            ShowCreation(polar_grid),
            Write(r_label),
            Write(theta_label),
            run_time=2
        )

        # 7. 显示最终的极坐标方程
        final_polar_eq = Tex("r(\\theta) = 5\\cos(\\theta) - \\cos(5\\theta)", 
                            color=YELLOW, font_size=50)
        final_polar_eq.to_corner(UL)
        explanation = Text("Function in Polar Coordinates", 
                          font_size=40, color=GREEN)
        explanation.next_to(final_polar_eq, DOWN)
        explanation.set_color_by_gradient(BLUE, GREEN, YELLOW, ORANGE, RED)
        
        self.play(
            Write(final_polar_eq),
            Write(explanation),
            FadeOut(transform_text)
        )
        self.wait(3)
          # 8. 最终展示
        self.play(
            self.camera.frame.animate.set_height(6),
            run_time=2,
            rate_func=smooth
        )
        self.wait(3)




if __name__ == "__main__":
    import os
    os.system("manimgl a.py WarpCartesianToPolar")
        
       

